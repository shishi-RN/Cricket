<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cricket Animation Controller</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #e5e5e5;
    }
    canvas {
      background-color: transparent;
      border: 2px solid #000;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <canvas id="cricketGround" width="700" height="1000"></canvas>
  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Canvas setup
    const canvas = document.getElementById("cricketGround");
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 380;
    
    const socket = io();
    let fieldingPositions = [];
    
    // Player configurations
    const players = {
      bowler: { 
        x: centerX, 
        y: centerY + 200,
        targetY: centerY + 100,
        width: 80,
        height: 120,
        img: null
      },
      batsman: {
        x: centerX,
        y: centerY - 100,
        batAngle: -Math.PI / 4,
        width: 80,
        height: 120,
        img: null
      },
      ball: {
        x: centerX,
        y: centerY + 300,
        radius: 10,
        visible: false,
        target: null
      }
    };
    
    // Create Audio objects for bowling and batting sounds
    const bowlSound = new Audio("bowling-sound.mp3");
    const batSound = new Audio("batting-sound.mp3");
    let batSoundPlayed = false; // flag to ensure the batting sound plays only once per swing
    
    // Socket event listeners
    socket.on('animate', async (data) => {
      await loadImages(data.bowlerImg, data.batterImg);
      const targetPosition = fieldingPositions.find(
        pos => pos.name === data.fieldingPosition
      );
      
      if (targetPosition) {
        players.ball.target = updatePositionForShot(targetPosition, data.shotType);
        startAnimationSequence();
      }
    });
    
    socket.on('fielding-positions', (positions) => {
      fieldingPositions = positions;
    });
    
    // Image loading helper
    async function loadImages(bowlerUrl, batterUrl) {
      players.bowler.img = await loadImage(bowlerUrl);
      players.batsman.img = await loadImage(batterUrl);
    }
    
    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = url;
      });
    }
    
    function updatePositionForShot(position, shotType) {
      switch(shotType.toLowerCase()) {
        case 'dot':
          return { ...position, distance: position.distance + 10 }; // Very short distance
        case 'single':
          return { ...position, distance: position.distance + 15 };
        case 'double':
          return { ...position, distance: position.distance + 16 };
        case 'triple':
          return { ...position, distance: position.distance + 17 };
        case 'four':
        case 'six':
          return { ...position, distance: position.distance + 50 };
        default:
          return position;
      }
    }
    
    function drawGround() {
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(144, 238, 144, 0.3)";
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
    
      ctx.fillStyle = "#d2b48c";
      ctx.fillRect(centerX - 15, centerY - 100, 30, 200);
    }
    
    function drawBat(x, y, angle) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle + Math.PI / 2); // Keep rotation offset if needed
      ctx.fillStyle = "#654321";
      // Body: Extends UPWARD from the handle (now at the pivot point)
      ctx.fillRect(-8, -120, 16, 120); // Starts at y=-120 (top) and ends at y=0 (handle)
      ctx.fillStyle = "#8B4513";
      // Handle: Positioned at the rotation pivot (base of the bat)
      ctx.fillRect(-5, 0, 10, 20); // Starts at y=0 (pivot) and extends downward
      ctx.strokeStyle = "#A0522D";
      ctx.lineWidth = 2;
      // Stripes: Adjusted to align with the body's new direction
      for (let i = -120; i < 0; i += 10) {
        ctx.beginPath();
        ctx.moveTo(-8, i);
        ctx.lineTo(8, i);
        ctx.stroke();
      }
      ctx.restore();
    }
    
    function drawPlayers() {
      if (players.bowler.img) {
        ctx.drawImage(
          players.bowler.img,
          players.bowler.x - players.bowler.width / 2,
          players.bowler.y - players.bowler.height / 2,
          players.bowler.width,
          players.bowler.height
        );
      }
    
      if (players.batsman.img) {
        ctx.drawImage(
          players.batsman.img,
          players.batsman.x - players.batsman.width / 2,
          players.batsman.y - players.batsman.height / 2,
          players.batsman.width,
          players.batsman.height
        );
      }
    
      drawBat(players.batsman.x, players.batsman.y, players.batsman.batAngle);
    
      if (players.ball.visible) {
        ctx.beginPath();
        ctx.arc(players.ball.x, players.ball.y, players.ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "#ff0000";
        ctx.fill();
      }
    }
    
    function startAnimationSequence() {
      // Play the bowling sound at the start of the bowling animation
      bowlSound.play();
      animateBowler();
    }
    
    function animateBowler() {
      const dy = players.bowler.targetY - players.bowler.y;
      players.bowler.y += dy * 0.1;
      
      if (Math.abs(dy) > 2) {
        requestAnimationFrame(animateBowler);
      } else {
        players.ball.visible = true;
        animateSwing();
      }
      drawFrame();
    }
    
    function animateSwing() {
      let swingProgress = 0;
      const startAngle = -Math.PI / 4;
      const endAngle = Math.PI / 4;
    
      function updateSwing() {
        if (swingProgress < 1) {
          swingProgress += 0.05;
          players.batsman.batAngle = startAngle + (endAngle - startAngle) * swingProgress;
          
          // Trigger batting sound once when swing reaches a threshold
          if (swingProgress > 0.3) {
            if (!batSoundPlayed) {
              batSound.play();
              batSoundPlayed = true;
            }
            players.ball.x = players.batsman.x + Math.cos(players.batsman.batAngle) * 60;
            players.ball.y = players.batsman.y + Math.sin(players.batsman.batAngle) * 60;
          }
          
          drawFrame();
          requestAnimationFrame(updateSwing);
        } else {
          animateBallToField();
        }
      }
      updateSwing();
    }
    
    function animateBallToField() {
      const targetX = centerX + Math.cos(players.ball.target.angle) * players.ball.target.distance;
      const targetY = centerY + Math.sin(players.ball.target.angle) * players.ball.target.distance;
    
      const dx = (targetX - players.ball.x) * 0.1;
      const dy = (targetY - players.ball.y) * 0.1;
    
      players.ball.x += dx;
      players.ball.y += dy;
    
      if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
        requestAnimationFrame(animateBallToField);
      } else {
        setTimeout(resetAnimation, 2000);
      }
      drawFrame();
    }
    
    function resetAnimation() {
      players.bowler.y = centerY + 300;
      players.ball.visible = false;
      players.ball.x = centerX;
      players.ball.y = centerY + 300;
      players.batsman.batAngle = -Math.PI / 4;
      batSoundPlayed = false; // Reset flag for the next swing
      drawFrame();
    }
    
    function drawFrame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGround();
      drawPlayers();
    }
    
    // Draw the initial frame
    drawFrame();
  </script>
</body>
</html>
